# Reality-First Orchestration

Aura no longer generates code directly. Instead, she produces high-fidelity specifications and hands them to an external terminal agent that writes the code while Aura supervises. This document explains the core services that make the new architecture work.

## Terminal Agent Loop

1. **DESIGN_BLUEPRINT / REFINE_CODE** – Aura gathers reality (LIST_FILES/READ_FILE), reasons about the work, and emits an `AgentSpecification` via `BlueprintHandler`.
2. **SPAWN_AGENT** – `TerminalAgentService` persists the specification to `.aura/<task_id>.md`, launches the configured terminal command, and exposes the process details as a `TerminalSession`.
3. **MONITOR_WORKSPACE** – `WorkspaceChangeMonitor` watches the workspace for created/modified/deleted files, ignoring Aura’s handoff directory.
4. **INTEGRATE_RESULTS** – Aura reads changed files, refreshes the lightweight `FileRegistry`, and updates `ProjectContext.active_files` so the next conversation turn sees reality.

The Reality-First Code Generation Protocol is mandatory at every stage: LIST_FILES → READ_FILE → verify contracts → verify dependencies → only then spawn the agent. Guessing is forbidden.

## Simplified File Registry (`src/aura/services/file_registry.py`)

The registry is now a minimal workspace index:

- Tracks the current file list under the active project root.
- Provides `refresh()`, `list_files()`, and `contains()` convenience methods.
- Ignores `.aura/` and `__pycache__/` to keep handoff artifacts out of user-facing listings.

Use it whenever you need the up-to-date project file list; no more planned vs. actual bookkeeping.

## Terminal Agent Service (`src/aura/services/terminal_agent_service.py`)

- Writes specifications to `.aura/<task_id>.md`.
- Adds `AURA_AGENT_SPEC_PATH` and `AURA_AGENT_TASK_ID` to the child process environment.
- Spawns the configured terminal command (default determined in `AuraApp`) and returns a `TerminalSession` with PID and spec path.
- Stores the latest session in `ProjectContext.extras["last_terminal_session"]` for UI and diagnostics.

## Workspace Change Monitor (`src/aura/services/workspace_monitor.py`)

- Produces `WorkspaceChanges` dataclass snapshots with `created`, `modified`, and `deleted` files.
- Skips `.aura/` and `__pycache__/` to avoid noise.
- Used by `MONITOR_WORKSPACE` and `INTEGRATE_RESULTS` to keep Aura’s memory in sync with reality.

## Executor Workflow (`src/aura/executor/executor.py`)

- `DESIGN_BLUEPRINT` / `REFINE_CODE` → returns an `AgentSpecification`, refreshes the file registry, and records the spec in `ProjectContext.extras["latest_specification"]`.
- `SPAWN_AGENT` → accepts `{"specification": "latest"}` (or an explicit payload), reconstructs the `AgentSpecification`, and launches the terminal agent.
- `MONITOR_WORKSPACE` → returns filesystem deltas and keeps `active_files` current when changes are detected.
- `INTEGRATE_RESULTS` → reads the changed files into memory, refreshes the registry, and reports what changed.

## Prompts

- `system_prompt.jinja2` and `reasoning_prompt.jinja2` now emphasise orchestrating terminal agents and disallow direct code generation.
- `terminal_agent_prompt.jinja2` is the new handoff template that embeds the Reality-First protocol, workspace snapshot, deliverables list, and quality standards.

## Configuration Notes

- The PowerShell/bash command used for the agent lives in `AuraApp._determine_default_agent_command()`; customise as needed.
- `requirements.txt` no longer includes semantic-search dependencies because AST/FAISS indexing has been removed.

## Success Criteria

- Every import, class, and method call generated by the external agent matches reality because Aura verified it first.
- Terminal sessions are observable and reproducible via the `.aura` ledger.
- Project memory (`ProjectContext.active_files`) stays current after every integration step.
