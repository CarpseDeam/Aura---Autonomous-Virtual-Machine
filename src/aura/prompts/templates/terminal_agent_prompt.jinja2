Task: {{ request }}
Project: {{ project_name or "Unknown" }}
Task ID: {{ task_id }}
Generated: {{ generated_at }}

## Mission Brief
{{ mission_summary }}

## Before You Touch Code
1. Open the freshly written `AGENTS.md`; it is the authoritative specification for this task.
2. Follow the Reality-First Code Generation Protocol:
   - `LIST_FILES` for every directory you expect to read or modify.
   - `READ_FILE` each module you plan to import or edit.
   - `READ_FILE` data contracts (DTOs, schemas, Pydantic models) to mirror names, optionality, and types.
   - `READ_FILE` constructors and call sites to confirm parameter ordering and dependencies.
3. Study the code style before editing: read 2-3 neighbouring modules that mirror this task (services → `src/aura/services/memory_manager.py`, executor logic → `src/aura/executor/file_operations.py`, models → `src/aura/models/agent_task.py`) and capture their naming, logging, and error-handling patterns.
4. Only begin editing after all phases are complete and captured in your working log. Skipping a phase is a protocol violation.

## Stealth Coding Protocol
- Match the existing style exactly—imports, logger usage, type hints, and docstrings should be indistinguishable from the surrounding code.
- Think through edge cases and unhappy paths; handle them proactively instead of leaving TODOs.
- When adapting existing files, preserve their structure and comment tone while extending behaviour.

## Workspace Snapshot
{% if project_files %}
- Existing files ({{ project_files|length }}):
{% for file_path in project_files %}
  - {{ file_path }}
{% endfor %}
{% else %}
- No existing files detected in the project directory. Confirm the expected structure with Aura before creating new ones.
{% endif %}

## Planned Deliverables
{% for file in planned_files %}
### {{ file.file_path }}
- Purpose: {{ file.description or "No description provided." }}
{% if file.methods %}
- Methods to provide:
{% for method in file.methods %}
  - {{ method }}
{% endfor %}
{% endif %}
{% if file.classes %}
- Classes to provide:
{% for cls in file.classes %}
  - {{ cls }}
{% endfor %}
{% endif %}
{% if file.extra %}
- Additional notes:
{% for note in file.extra %}
  - {{ note }}
{% endfor %}
{% endif %}
{% if not file.methods and not file.classes and not file.extra %}
- No further detail available—confirm specifics with Aura before implementing.
{% endif %}
{% endfor %}
{% if not planned_files %}
- No explicit files were outlined. Pause and sync with Aura to co-define the deliverable before writing code.
{% endif %}

## Collaboration Norms
- Keep scope proportional to the request. Reuse existing patterns; introduce new abstractions only when the blueprint demands them.
- Narrate major checkpoints in the terminal so Aura can monitor and persist project memory.
- Stage work iteratively: implement a focused change set, self-review, then announce completion.

## Quality Expectations
- Ship production-ready results that match project conventions, include full type hints, and update docstrings when behaviour changes.
- Add or update tests whenever behaviour changes or new logic appears; focus on pragmatic coverage that proves the feature works.
- Leave files cleaner than you found them—follow existing linting/formatting conventions and remove dead code discovered during inspection.

## Handoff Completion
1. Confirm all Reality-First steps were executed.
2. Apply the changes directly to the workspace.
3. Write `.aura/{{ task_id }}.done` with a short summary of the work performed.
4. Report status and next steps via terminal output so Aura can integrate the results.

Aura is monitoring for filesystem changes and will capture the outcome in project memory.
