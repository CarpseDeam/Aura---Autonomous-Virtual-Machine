import re
import ast
import logging
from typing import Dict, List, Any, Optional
from src.aura.app.event_bus import EventBus
from src.aura.models.events import Event

logger = logging.getLogger(__name__)


class ValidationService:
    """
    The Quality Gate - ValidationService enforces programmatic validation of generated code
    against the granular specifications from the Architect's blueprint.
    
    This service ensures that every piece of generated code conforms to the exact
    specifications defined in the multi-specialist system.
    """

    def __init__(self, event_bus: EventBus):
        """Initialize the ValidationService with event bus integration."""
        self.event_bus = event_bus
        self._register_event_handlers()
        logger.info("ValidationService initialized - Quality Gate is active")

    def _register_event_handlers(self):
        """Subscribe to validation-related events."""
        self.event_bus.subscribe("VALIDATE_CODE", self._handle_validate_code)

    def _handle_validate_code(self, event: Event):
        """Handle code validation requests from the event bus."""
        payload = event.payload
        spec = payload.get("spec")
        generated_code = payload.get("generated_code")
        task_id = payload.get("task_id")
        file_path = payload.get("file_path", "unknown")

        if not spec or not generated_code:
            logger.error(f"Invalid validation request for task {task_id}: missing spec or code")
            self._dispatch_validation_failed(task_id, file_path, "Missing specification or generated code")
            return

        logger.info(f"Quality Gate: Validating code for task {task_id} in file {file_path}")
        
        # Prepare filename for internal logging
        filename = file_path.split('/')[-1] if '/' in file_path else file_path
        
        # Perform the validation
        is_valid, validation_errors = self.validate_code(spec, generated_code)
        
        if is_valid:
            logger.info(f"Quality Gate: Validation PASSED for task {task_id}")
            self._dispatch_validation_successful(task_id, file_path, generated_code)
            # Dispatch CODE_GENERATED event for the CodeViewerWindow to update
            self.event_bus.dispatch(Event(
                event_type="CODE_GENERATED",
                payload={"file_path": file_path, "code": generated_code}
            ))
        else:
            logger.warning(f"Quality Gate: Validation FAILED for task {task_id}: {'; '.join(validation_errors)}")
            self._dispatch_validation_failed(task_id, file_path, "; ".join(validation_errors))

    def validate_code(self, spec: Dict[str, Any], generated_code: str) -> tuple[bool, List[str]]:
        """
        Core validation method that programmatically enforces the specification.
        
        Args:
            spec: The specification from the architect's blueprint
            generated_code: The code generated by the engineer specialist
            
        Returns:
            Tuple of (is_valid: bool, errors: List[str])
        """
        errors = []
        
        # Validation Strategy 1: Linguistic/Regex-based checks for required symbols
        if "class_name" in spec and "method_name" in spec:
            # Validating a method within a class
            errors.extend(self._validate_class_method(spec, generated_code))
        elif "function_name" in spec:
            # Validating a standalone function
            errors.extend(self._validate_function(spec, generated_code))
        else:
            errors.append("Unknown specification type - cannot determine validation strategy")
            
        # Validation Strategy 2: AST-based validation for syntax correctness
        try:
            ast.parse(generated_code)
            logger.debug("AST validation passed - code is syntactically valid")
        except SyntaxError as e:
            errors.append(f"Syntax error in generated code: {str(e)}")
            logger.error(f"AST validation failed: {str(e)}")
        
        is_valid = len(errors) == 0
        return is_valid, errors

    def _validate_class_method(self, spec: Dict[str, Any], generated_code: str) -> List[str]:
        """
        Validate that a class method is properly implemented according to spec."""
        errors = []
        
        class_name = spec.get("class_name", "")
        method_name = spec.get("method_name", "")
        signature = spec.get("signature", "")
        
        # Check 1: Class definition exists
        class_pattern = rf'class\s+{re.escape(class_name)}\s*[\(\:]'
        if not re.search(class_pattern, generated_code):
            errors.append(f"Missing class definition: 'class {class_name}'")
        
        # Check 2: Method definition exists within the class
        # This regex looks for the method within indented blocks (assuming proper Python indentation)
        method_pattern = rf'def\s+{re.escape(method_name)}\s*\('
        if not re.search(method_pattern, generated_code):
            errors.append(f"Missing method definition: 'def {method_name}('")
        
        # Check 3: Method signature validation (basic parameter checking)
        if signature and method_name != "__init__":  # Skip complex __init__ validation for now
            # Extract parameter names from signature
            try:
                # Simple signature validation - check if method has expected parameters
                if "self" in signature and method_name in generated_code:
                    # Look for the method definition with self parameter
                    self_method_pattern = rf'def\s+{re.escape(method_name)}\s*\(\s*self'
                    if not re.search(self_method_pattern, generated_code):
                        errors.append(f"Method {method_name} must include 'self' parameter")
            except Exception as e:
                logger.debug(f"Signature validation warning for {method_name}: {e}")
        
        return errors

    def _validate_function(self, spec: Dict[str, Any], generated_code: str) -> List[str]:
        """
        Validate that a standalone function is properly implemented according to spec."""
        errors = []
        
        function_name = spec.get("function_name", "")
        signature = spec.get("signature", "")
        
        # Check 1: Function definition exists
        function_pattern = rf'def\s+{re.escape(function_name)}\s*\('
        if not re.search(function_pattern, generated_code):
            errors.append(f"Missing function definition: 'def {function_name}('")
        
        # Check 2: Basic signature validation
        if signature:
            try:
                # Extract the function signature and validate basic structure
                # This is a simplified check - more sophisticated validation can be added
                if function_name in generated_code:
                    logger.debug(f"Function {function_name} found in generated code")
                else:
                    errors.append(f"Function {function_name} not found in generated code")
            except Exception as e:
                logger.debug(f"Signature validation warning for {function_name}: {e}")
        
        return errors

    def _dispatch_validation_successful(self, task_id: str, file_path: str, validated_code: str):
        """
        Dispatch validation successful event."""
        self.event_bus.dispatch(Event(
            event_type="VALIDATION_SUCCESSFUL",
            payload={
                "task_id": task_id,
                "file_path": file_path,
                "validated_code": validated_code
            }
        ))

    def _dispatch_validation_failed(self, task_id: str, file_path: str, error_message: str):
        """
        Dispatch validation failed event."""
        self.event_bus.dispatch(Event(
            event_type="VALIDATION_FAILED",
            payload={
                "task_id": task_id,
                "file_path": file_path,
                "error_message": error_message
            }
        ))
