"""Markdown generation for project memory system.

This module handles all markdown formatting and file generation
for the PROJECT_MEMORY.md files.
"""

import logging
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List

from .memory_models import (
    ArchitectureDecision,
    CodePattern,
    KnownIssue,
    ProjectMemory,
    TimelineEntry,
)

logger = logging.getLogger(__name__)


class MemoryMarkdownGenerator:
    """Generates markdown content and files from ProjectMemory."""

    def generate_content(self, memory: ProjectMemory) -> str:
        """
        Generate markdown content from memory structure.

        Args:
            memory: ProjectMemory instance

        Returns:
            Formatted markdown string
        """
        lines = [
            f"# Project Memory: {memory.project_name}",
            "",
            f"*Last updated: {memory.last_updated.strftime('%Y-%m-%d %H:%M UTC')}*",
            "",
        ]

        # Architecture Decisions
        if memory.architecture_decisions:
            lines.extend(self._generate_architecture_section(memory.architecture_decisions))

        # Code Patterns
        if memory.code_patterns:
            lines.extend(self._generate_patterns_section(memory.code_patterns))

        # Project Timeline (most recent 20 entries)
        if memory.timeline:
            lines.extend(self._generate_timeline_section(memory.timeline))

        # Current State
        if memory.current_state:
            lines.extend(self._generate_state_section(memory.current_state))

        # Known Issues
        if memory.known_issues:
            lines.extend(self._generate_issues_section(memory.known_issues))

        # Footer
        lines.extend([
            "---",
            "",
            "*This file is auto-generated by Aura's Project Memory System.*",
            "*Last sync: " + datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC') + "*",
        ])

        return "\n".join(lines)

    def _generate_architecture_section(
        self,
        decisions: List[ArchitectureDecision]
    ) -> List[str]:
        """Generate architecture decisions section."""
        lines = [
            "## Architecture Decisions",
            "",
        ]

        # Group by category
        decisions_by_category: Dict[str, List[ArchitectureDecision]] = {}
        for decision in decisions:
            if decision.category not in decisions_by_category:
                decisions_by_category[decision.category] = []
            decisions_by_category[decision.category].append(decision)

        # Render each category
        for category in sorted(decisions_by_category.keys()):
            lines.append(f"### {category}")
            for decision in decisions_by_category[category]:
                lines.append(f"- **{decision.decision}**: {decision.rationale}")
            lines.append("")

        return lines

    def _generate_patterns_section(
        self,
        patterns: List[CodePattern]
    ) -> List[str]:
        """Generate code patterns section."""
        lines = [
            "## Code Patterns We Follow",
            "",
        ]

        # Group by category
        patterns_by_category: Dict[str, List[CodePattern]] = {}
        for pattern in patterns:
            if pattern.category not in patterns_by_category:
                patterns_by_category[pattern.category] = []
            patterns_by_category[pattern.category].append(pattern)

        # Render each category
        for category in sorted(patterns_by_category.keys()):
            lines.append(f"### {category}")
            for pattern in patterns_by_category[category]:
                lines.append(f"- {pattern.pattern}")
                if pattern.example:
                    lines.extend([
                        "  ```",
                        f"  {pattern.example}",
                        "  ```",
                    ])
            lines.append("")

        return lines

    def _generate_timeline_section(
        self,
        timeline: List[TimelineEntry]
    ) -> List[str]:
        """Generate project timeline section."""
        lines = [
            "## Project Timeline",
            "",
        ]

        # Sort by timestamp descending, take most recent 20
        sorted_timeline = sorted(timeline, key=lambda e: e.timestamp, reverse=True)[:20]

        for entry in sorted_timeline:
            date_str = entry.timestamp.strftime('%Y-%m-%d')
            outcome_emoji = self._get_outcome_emoji(entry.outcome)
            lines.append(f"- **{date_str}** {outcome_emoji}: {entry.description}")
            if entry.notes:
                lines.append(f"  - *{entry.notes}*")

        lines.append("")
        return lines

    def _generate_state_section(
        self,
        current_state: Dict[str, any]
    ) -> List[str]:
        """Generate current state section."""
        lines = [
            "## Current State",
            "",
        ]

        for key, value in current_state.items():
            if value is None:
                continue
            if isinstance(value, list):
                lines.append(f"- **{key}**:")
                for item in value:
                    lines.append(f"  - {item}")
            elif isinstance(value, dict):
                lines.append(f"- **{key}**:")
                for sub_key, sub_value in value.items():
                    lines.append(f"  - {sub_key}: {sub_value}")
            else:
                lines.append(f"- **{key}**: {value}")

        lines.append("")
        return lines

    def _generate_issues_section(
        self,
        known_issues: List[KnownIssue]
    ) -> List[str]:
        """Generate known issues section."""
        lines = [
            "## Known Issues",
            "",
        ]

        # Filter unresolved issues
        unresolved = [issue for issue in known_issues if not issue.resolved_at]

        if unresolved:
            # Group by severity
            by_severity = {"critical": [], "high": [], "medium": [], "low": []}
            for issue in unresolved:
                severity = issue.severity.lower()
                if severity in by_severity:
                    by_severity[severity].append(issue)

            # Render each severity level
            for severity in ["critical", "high", "medium", "low"]:
                if by_severity[severity]:
                    severity_emoji = self._get_severity_emoji(severity)
                    lines.append(f"### {severity_emoji} {severity.title()}")
                    for issue in by_severity[severity]:
                        lines.append(f"- {issue.description}")
                    lines.append("")

        return lines

    def _get_outcome_emoji(self, outcome: str) -> str:
        """Get emoji for timeline outcome."""
        outcome_lower = outcome.lower()
        if outcome_lower == "success":
            return "✅"
        elif outcome_lower == "partial":
            return "⚠️"
        else:
            return "❌"

    def _get_severity_emoji(self, severity: str) -> str:
        """Get emoji for issue severity."""
        severity_map = {
            "critical": "🔥",
            "high": "🔴",
            "medium": "🟡",
            "low": "🟢"
        }
        return severity_map.get(severity.lower(), "🟡")

    def generate_file(
        self,
        memory: ProjectMemory,
        project_path: Path
    ) -> None:
        """
        Generate PROJECT_MEMORY.md file on disk.

        Args:
            memory: ProjectMemory instance
            project_path: Path to project directory

        Raises:
            OSError: If file write fails
        """
        memory_file = project_path / "PROJECT_MEMORY.md"
        content = self.generate_content(memory)

        try:
            memory_file.write_text(content, encoding="utf-8")
            logger.info("Generated PROJECT_MEMORY.md at %s", memory_file)
        except OSError as exc:
            logger.error("Failed to write PROJECT_MEMORY.md: %s", exc)
            raise
